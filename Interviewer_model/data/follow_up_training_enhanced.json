[
  {
    "id": 1,
    "question": "请介绍一下你的Redis使用经验？",
    "answer": "我不太了解Redis，没怎么用过。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.8,
      "filler_count": 5,
      "answer_length": 15
    },
    "label": "NEXT_TOPIC",
    "reason": "候选人明确表示不了解，应该换话题",
    "reason_type": "negative",
    "qwen_should_say": "没关系，我们换个话题。"
  },
  {
    "id": 2,
    "question": "请介绍一下你的Redis使用经验？",
    "answer": "我在项目中用Redis做缓存，主要缓存用户session和热点数据。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.2,
      "filler_count": 1,
      "answer_length": 45
    },
    "label": "FOLLOW_UP",
    "reason": "候选人回答了且有内容，可以追问具体实现",
    "qwen_should_say": "很好！能具体说说..."
  },
  {
    "id": 3,
    "question": "那你遇到过缓存穿透的问题吗？怎么解决的？",
    "answer": "遇到过，我用了布隆过滤器加空值缓存的方案。对于不存在的key，先用布隆过滤器拦截，然后缓存空值设置短过期时间。还监控了缓存命中率，及时发现异常。",
    "context": {
      "follow_up_depth": 3,
      "hesitation_score": 0.15,
      "filler_count": 0,
      "answer_length": 120
    },
    "label": "NEXT_TOPIC",
    "reason": "已经追问3层且候选人都答得很好，Redis这个话题已经充分展示了能力，应该换话题",
    "reason_type": "positive",
    "qwen_should_say": "很好！Redis这块你掌握得不错。我们换个话题..."
  },
  {
    "id": 4,
    "question": "能举个具体的优化案例吗？",
    "answer": "嗯...具体的案例...我想想...好像有一次是查询用户和订单，然后...嗯...具体怎么做的我有点记不清了。",
    "context": {
      "follow_up_depth": 3,
      "hesitation_score": 0.85,
      "filler_count": 12,
      "answer_length": 60
    },
    "label": "NEXT_TOPIC",
    "reason": "已经追问3层，候选人明显答不上来具体细节，应该换话题",
    "reason_type": "negative",
    "qwen_should_say": "没关系，这些细节确实容易忘。我们换个话题..."
  },
  {
    "id": 5,
    "question": "你在项目中是如何处理Git分支管理的？",
    "answer": "我们团队用Git Flow，主分支master和develop，功能开发在feature分支，上线前合并到release分支测试，发布后打tag。遇到线上bug就从master切hotfix分支修复。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.1,
      "filler_count": 0,
      "answer_length": 105
    },
    "label": "FOLLOW_UP",
    "reason": "候选人对Git Flow很熟悉，可以追问具体实践",
    "qwen_should_say": "不错！那你遇到过复杂的合并冲突吗？怎么解决的？"
  },
  {
    "id": 6,
    "question": "那你遇到过需要回滚代码的情况吗？怎么操作的？",
    "answer": "遇到过。如果是commit还没push，用git reset。如果已经push了，用git revert生成反向提交。线上紧急回滚的话，直接git revert然后push，保留完整的历史记录。",
    "context": {
      "follow_up_depth": 2,
      "hesitation_score": 0.15,
      "filler_count": 1,
      "answer_length": 110
    },
    "label": "FOLLOW_UP",
    "reason": "回答专业，可以继续追问边界情况",
    "qwen_should_say": "很专业！那reset和revert的区别你能详细说说吗？"
  },
  {
    "id": 7,
    "question": "reset和revert的区别你能详细说说吗？",
    "answer": "reset是回退到某个提交，会改变历史记录，适合本地还没push的情况。revert是生成一个新提交来撤销之前的修改，不改变历史，适合已经push的代码。reset有--soft、--mixed、--hard三种模式，影响工作区和暂存区的状态。",
    "context": {
      "follow_up_depth": 3,
      "hesitation_score": 0.1,
      "filler_count": 0,
      "answer_length": 140
    },
    "label": "NEXT_TOPIC",
    "reason": "已经追问3层，候选人对Git掌握很扎实，已经充分展示了版本控制能力，应该换到其他话题",
    "reason_type": "positive",
    "qwen_should_say": "非常好！Git这块你掌握得很扎实。我们聊聊其他的..."
  },
  {
    "id": 8,
    "question": "你对Docker了解吗？",
    "answer": "了解一些基础概念，但是没有实际使用经验。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.4,
      "filler_count": 3,
      "answer_length": 25
    },
    "label": "NEXT_TOPIC",
    "reason": "候选人只知道概念没有实践，不适合深入追问",
    "reason_type": "negative",
    "qwen_should_say": "好的，那我们聊聊你有实践经验的技术吧。"
  },
  {
    "id": 9,
    "question": "你在Python中用过异步编程吗？",
    "answer": "用过，我用asyncio做过爬虫和API服务。用async/await定义协程，asyncio.gather并发执行任务，还用了aiohttp做异步HTTP请求。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.15,
      "filler_count": 1,
      "answer_length": 95
    },
    "label": "FOLLOW_UP",
    "reason": "有实践经验，可以追问具体场景",
    "qwen_should_say": "很好！能说说你用asyncio做爬虫时是怎么控制并发数的吗？"
  },
  {
    "id": 10,
    "question": "那你是怎么处理异步任务中的异常的？",
    "answer": "我会在每个协程里加try-except捕获异常，然后记录日志。用asyncio.gather的时候设置return_exceptions=True，这样一个任务出错不影响其他任务。还会设置超时timeout避免某个任务卡死。",
    "context": {
      "follow_up_depth": 2,
      "hesitation_score": 0.2,
      "filler_count": 1,
      "answer_length": 115
    },
    "label": "FOLLOW_UP",
    "reason": "理解深入，可以继续追问边界情况",
    "qwen_should_say": "不错！那你遇到过事件循环阻塞的问题吗？"
  },
  {
    "id": 11,
    "question": "遇到过事件循环阻塞的问题吗？怎么定位和解决的？",
    "answer": "遇到过，有一次在协程里调用了同步的数据库操作，导致整个事件循环卡住。我用loop.run_in_executor把同步操作放到线程池执行，问题就解决了。还用了logging打印协程运行时间，找到耗时的操作。",
    "context": {
      "follow_up_depth": 3,
      "hesitation_score": 0.15,
      "filler_count": 1,
      "answer_length": 125
    },
    "label": "NEXT_TOPIC",
    "reason": "已经追问3层，候选人对Python异步编程理解很深，已经充分展示了能力，可以换话题了",
    "reason_type": "positive",
    "qwen_should_say": "优秀！异步编程这块你掌握得很好。我们换个方向..."
  },
  {
    "id": 12,
    "question": "你对微服务架构了解吗？",
    "answer": "嗯...听说过，但是我们项目都是单体应用，没接触过微服务。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.7,
      "filler_count": 6,
      "answer_length": 30
    },
    "label": "NEXT_TOPIC",
    "reason": "候选人没有微服务经验，应该换到他熟悉的话题",
    "reason_type": "negative",
    "qwen_should_say": "理解，那我们聊聊你现在项目中用的技术栈吧。"
  },
  {
    "id": 13,
    "question": "你在项目中用过消息队列吗？",
    "answer": "用过RabbitMQ，主要用来做异步任务处理和服务解耦。比如用户下单后，发消息到队列，库存服务和通知服务分别消费，互不影响。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.2,
      "filler_count": 1,
      "answer_length": 85
    },
    "label": "FOLLOW_UP",
    "reason": "有实践经验，可以追问具体实现",
    "qwen_should_say": "不错！那你是怎么保证消息不丢失的？"
  },
  {
    "id": 14,
    "question": "那如果消费失败了怎么办？有重试机制吗？",
    "answer": "有，我设置了死信队列DLX。消息消费失败会重新入队，重试3次还失败就进死信队列。然后定时任务监控死信队列，人工处理或重新投递。还用了幂等性设计，避免重复消费。",
    "context": {
      "follow_up_depth": 2,
      "hesitation_score": 0.15,
      "filler_count": 0,
      "answer_length": 120
    },
    "label": "FOLLOW_UP",
    "reason": "设计合理，可以继续追问高级场景",
    "qwen_should_say": "设计得不错！那你遇到过消息积压的情况吗？怎么处理的？"
  },
  {
    "id": 15,
    "question": "遇到过消息积压吗？怎么处理的？",
    "answer": "遇到过，有一次消费者挂了，消息积压了几万条。我先紧急重启消费者，然后增加消费者实例数做水平扩展。还优化了消费逻辑，把耗时操作异步化，提升了消费速度。后来加了监控告警，及时发现积压。",
    "context": {
      "follow_up_depth": 3,
      "hesitation_score": 0.2,
      "filler_count": 1,
      "answer_length": 135
    },
    "label": "NEXT_TOPIC",
    "reason": "已经追问3层，候选人对消息队列有深入理解和实践经验，已经充分展示了分布式系统能力，可以换话题",
    "reason_type": "positive",
    "qwen_should_say": "很好！消息队列这块你实践经验丰富。我们换个话题..."
  },
  {
    "id": 16,
    "question": "你对Kubernetes了解吗？",
    "answer": "不了解，我们公司还在用传统部署。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.5,
      "filler_count": 2,
      "answer_length": 20
    },
    "label": "NEXT_TOPIC",
    "reason": "候选人没有K8s经验，应该换话题",
    "reason_type": "negative",
    "qwen_should_say": "好的，那我们聊聊你熟悉的部署方式。"
  },
  {
    "id": 17,
    "question": "你在数据库优化方面有什么经验？",
    "answer": "我主要做过索引优化和慢查询优化。用EXPLAIN分析查询计划，在WHERE和JOIN字段建索引。还做过分表，把大表按时间分成多个小表，查询速度提升明显。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.2,
      "filler_count": 1,
      "answer_length": 95
    },
    "label": "FOLLOW_UP",
    "reason": "有优化经验，可以追问具体案例",
    "qwen_should_say": "不错！能举个慢查询优化的具体案例吗？"
  },
  {
    "id": 18,
    "question": "那你知道什么情况下索引会失效吗？",
    "answer": "知道几种：对索引字段用函数、隐式类型转换、like左模糊、or条件、!= 和 not in、复合索引不满足最左前缀。这些都会导致索引失效，需要避免。",
    "context": {
      "follow_up_depth": 2,
      "hesitation_score": 0.15,
      "filler_count": 0,
      "answer_length": 95
    },
    "label": "FOLLOW_UP",
    "reason": "理论知识扎实，可以继续追问实践",
    "qwen_should_say": "总结得很好！那你在实际项目中遇到过这些情况吗？"
  },
  {
    "id": 19,
    "question": "那你在实际项目中遇到过这些情况吗？怎么发现和解决的？",
    "answer": "遇到过，有一次查询很慢，发现WHERE条件用了DATE(create_time)，导致索引失效。我改成create_time BETWEEN ... AND ...，走了索引，速度快了几十倍。还有一次是隐式转换，字段是varchar但传入了int，加了引号就好了。",
    "context": {
      "follow_up_depth": 3,
      "hesitation_score": 0.2,
      "filler_count": 1,
      "answer_length": 140
    },
    "label": "NEXT_TOPIC",
    "reason": "已经追问3层，候选人对数据库优化有理论知识也有实践经验，充分展示了能力，可以换话题",
    "reason_type": "positive",
    "qwen_should_say": "很好！数据库优化这块你经验丰富。我们换个方向..."
  },
  {
    "id": 20,
    "question": "你对区块链技术了解吗？",
    "answer": "不太了解，这块我没接触过。",
    "context": {
      "follow_up_depth": 1,
      "hesitation_score": 0.6,
      "filler_count": 4,
      "answer_length": 15
    },
    "label": "NEXT_TOPIC",
    "reason": "候选人不了解区块链，应该换到他熟悉的领域",
    "reason_type": "negative",
    "qwen_should_say": "没关系，我们聊聊你擅长的技术。"
  }
]

